// @flow
/* eslint-disable no-use-before-define */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}


/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type BodyApplyImageImageBackgroundRemovalPost = {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageBackgroundRemovalPost
     */
    image: any;
}


/**
 * 
 * @export
 */
export type BodyApplyImageImageColorizationPost = {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageColorizationPost
     */
    image: any;
}


/**
 * 
 * @export
 */
export type BodyApplyImageImageFaceBluringPost = {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageFaceBluringPost
     */
    image: any;
}


/**
 * 
 * @export
 */
export type BodyApplyImageImageRestorationPost = {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageRestorationPost
     */
    image: any;
}


/**
 * 
 * @export
 */
export type BodyApplyImageImageSuperResolutionPost = {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageSuperResolutionPost
     */
    image: any;
}


/**
 * 
 * @export
 */
export type BodyApplyImageImageUncolorizationPost = {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageUncolorizationPost
     */
    image: any;
}


/**
 * 
 * @export
 */
export type HTTPValidationError = {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}


/**
 * 
 * @export
 */
export type ValidationError = {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}




/**
 * ImageImageBackgroundRemovalApi - fetch parameter creator
 * @export
 */
export const ImageImageBackgroundRemovalApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the background-removal task for a given models
         * @throws {RequiredError}
         */
        applyImageImageBackgroundRemovalPost(image: any, model?: 'xception' | 'mobilenet', options: RequestOptions): FetchArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageBackgroundRemovalPost.');
            }
            const localVarPath = `/image/image/background-removal/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            if (image !== undefined) {
                localVarFormParams.set('image', ((image:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for background-removal
         * @throws {RequiredError}
         */
        getVersionsImageImageBackgroundRemovalGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/image/image/background-removal/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ImageImageBackgroundRemovalApiType = { 
    applyImageImageBackgroundRemovalPost(image: any, model?: 'xception' | 'mobilenet', options?: RequestOptions): Promise<Object>,

    getVersionsImageImageBackgroundRemovalGet(options?: RequestOptions): Promise<Object>,
}

/**
 * ImageImageBackgroundRemovalApi - factory function to inject configuration 
 * @export
 */
export const ImageImageBackgroundRemovalApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ImageImageBackgroundRemovalApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the background-removal task for a given models
         * @throws {RequiredError}
         */
        applyImageImageBackgroundRemovalPost(image: any, model?: 'xception' | 'mobilenet', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ImageImageBackgroundRemovalApiFetchParamCreator(configuration).applyImageImageBackgroundRemovalPost(image, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for background-removal
         * @throws {RequiredError}
         */
        getVersionsImageImageBackgroundRemovalGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ImageImageBackgroundRemovalApiFetchParamCreator(configuration).getVersionsImageImageBackgroundRemovalGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * ImageImageColorizationApi - fetch parameter creator
 * @export
 */
export const ImageImageColorizationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the colorization task for a given models
         * @throws {RequiredError}
         */
        applyImageImageColorizationPost(image: any, model?: 'deoldify-artistic' | 'deoldify-stable', options: RequestOptions): FetchArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageColorizationPost.');
            }
            const localVarPath = `/image/image/colorization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            if (image !== undefined) {
                localVarFormParams.set('image', ((image:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for colorization
         * @throws {RequiredError}
         */
        getVersionsImageImageColorizationGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/image/image/colorization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ImageImageColorizationApiType = { 
    applyImageImageColorizationPost(image: any, model?: 'deoldify-artistic' | 'deoldify-stable', options?: RequestOptions): Promise<Object>,

    getVersionsImageImageColorizationGet(options?: RequestOptions): Promise<Object>,
}

/**
 * ImageImageColorizationApi - factory function to inject configuration 
 * @export
 */
export const ImageImageColorizationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ImageImageColorizationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the colorization task for a given models
         * @throws {RequiredError}
         */
        applyImageImageColorizationPost(image: any, model?: 'deoldify-artistic' | 'deoldify-stable', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ImageImageColorizationApiFetchParamCreator(configuration).applyImageImageColorizationPost(image, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for colorization
         * @throws {RequiredError}
         */
        getVersionsImageImageColorizationGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ImageImageColorizationApiFetchParamCreator(configuration).getVersionsImageImageColorizationGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * ImageImageFaceBluringApi - fetch parameter creator
 * @export
 */
export const ImageImageFaceBluringApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the face-bluring task for a given models
         * @throws {RequiredError}
         */
        applyImageImageFaceBluringPost(image: any, model?: 'ageitgey', options: RequestOptions): FetchArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageFaceBluringPost.');
            }
            const localVarPath = `/image/image/face-bluring/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            if (image !== undefined) {
                localVarFormParams.set('image', ((image:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for face-bluring
         * @throws {RequiredError}
         */
        getVersionsImageImageFaceBluringGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/image/image/face-bluring/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ImageImageFaceBluringApiType = { 
    applyImageImageFaceBluringPost(image: any, model?: 'ageitgey', options?: RequestOptions): Promise<Object>,

    getVersionsImageImageFaceBluringGet(options?: RequestOptions): Promise<Object>,
}

/**
 * ImageImageFaceBluringApi - factory function to inject configuration 
 * @export
 */
export const ImageImageFaceBluringApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ImageImageFaceBluringApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the face-bluring task for a given models
         * @throws {RequiredError}
         */
        applyImageImageFaceBluringPost(image: any, model?: 'ageitgey', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ImageImageFaceBluringApiFetchParamCreator(configuration).applyImageImageFaceBluringPost(image, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for face-bluring
         * @throws {RequiredError}
         */
        getVersionsImageImageFaceBluringGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ImageImageFaceBluringApiFetchParamCreator(configuration).getVersionsImageImageFaceBluringGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * ImageImageRestorationApi - fetch parameter creator
 * @export
 */
export const ImageImageRestorationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the restoration task for a given models
         * @throws {RequiredError}
         */
        applyImageImageRestorationPost(image: any, model?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageRestorationPost.');
            }
            const localVarPath = `/image/image/restoration/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            if (image !== undefined) {
                localVarFormParams.set('image', ((image:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for restoration
         * @throws {RequiredError}
         */
        getVersionsImageImageRestorationGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/image/image/restoration/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ImageImageRestorationApiType = { 
    applyImageImageRestorationPost(image: any, model?: string, options?: RequestOptions): Promise<Object>,

    getVersionsImageImageRestorationGet(options?: RequestOptions): Promise<Object>,
}

/**
 * ImageImageRestorationApi - factory function to inject configuration 
 * @export
 */
export const ImageImageRestorationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ImageImageRestorationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the restoration task for a given models
         * @throws {RequiredError}
         */
        applyImageImageRestorationPost(image: any, model?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ImageImageRestorationApiFetchParamCreator(configuration).applyImageImageRestorationPost(image, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for restoration
         * @throws {RequiredError}
         */
        getVersionsImageImageRestorationGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ImageImageRestorationApiFetchParamCreator(configuration).getVersionsImageImageRestorationGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * ImageImageSuperResolutionApi - fetch parameter creator
 * @export
 */
export const ImageImageSuperResolutionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the super-resolution task for a given models
         * @throws {RequiredError}
         */
        applyImageImageSuperResolutionPost(image: any, model?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageSuperResolutionPost.');
            }
            const localVarPath = `/image/image/super-resolution/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            if (image !== undefined) {
                localVarFormParams.set('image', ((image:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for super-resolution
         * @throws {RequiredError}
         */
        getVersionsImageImageSuperResolutionGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/image/image/super-resolution/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ImageImageSuperResolutionApiType = { 
    applyImageImageSuperResolutionPost(image: any, model?: string, options?: RequestOptions): Promise<Object>,

    getVersionsImageImageSuperResolutionGet(options?: RequestOptions): Promise<Object>,
}

/**
 * ImageImageSuperResolutionApi - factory function to inject configuration 
 * @export
 */
export const ImageImageSuperResolutionApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ImageImageSuperResolutionApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the super-resolution task for a given models
         * @throws {RequiredError}
         */
        applyImageImageSuperResolutionPost(image: any, model?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ImageImageSuperResolutionApiFetchParamCreator(configuration).applyImageImageSuperResolutionPost(image, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for super-resolution
         * @throws {RequiredError}
         */
        getVersionsImageImageSuperResolutionGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ImageImageSuperResolutionApiFetchParamCreator(configuration).getVersionsImageImageSuperResolutionGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * ImageImageUncolorizationApi - fetch parameter creator
 * @export
 */
export const ImageImageUncolorizationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the uncolorization task for a given models
         * @throws {RequiredError}
         */
        applyImageImageUncolorizationPost(image: any, model?: 'v1', options: RequestOptions): FetchArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageUncolorizationPost.');
            }
            const localVarPath = `/image/image/uncolorization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            if (image !== undefined) {
                localVarFormParams.set('image', ((image:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for uncolorization
         * @throws {RequiredError}
         */
        getVersionsImageImageUncolorizationGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/image/image/uncolorization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ImageImageUncolorizationApiType = { 
    applyImageImageUncolorizationPost(image: any, model?: 'v1', options?: RequestOptions): Promise<Object>,

    getVersionsImageImageUncolorizationGet(options?: RequestOptions): Promise<Object>,
}

/**
 * ImageImageUncolorizationApi - factory function to inject configuration 
 * @export
 */
export const ImageImageUncolorizationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ImageImageUncolorizationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the uncolorization task for a given models
         * @throws {RequiredError}
         */
        applyImageImageUncolorizationPost(image: any, model?: 'v1', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ImageImageUncolorizationApiFetchParamCreator(configuration).applyImageImageUncolorizationPost(image, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for uncolorization
         * @throws {RequiredError}
         */
        getVersionsImageImageUncolorizationGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = ImageImageUncolorizationApiFetchParamCreator(configuration).getVersionsImageImageUncolorizationGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextAutocorrectApi - fetch parameter creator
 * @export
 */
export const TextTextAutocorrectApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the autocorrect task for a given models
         * @throws {RequiredError}
         */
        applyTextTextAutocorrectPost(sentence?: string, model?: 'flexudy-t5-base-multi-sentence-doctor', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/autocorrect/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (sentence !== undefined) {
                localVarQueryParameter['sentence'] = ((sentence:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for autocorrect
         * @throws {RequiredError}
         */
        getVersionsTextTextAutocorrectGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/autocorrect/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextAutocorrectApiType = { 
    applyTextTextAutocorrectPost(sentence?: string, model?: 'flexudy-t5-base-multi-sentence-doctor', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextAutocorrectGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextAutocorrectApi - factory function to inject configuration 
 * @export
 */
export const TextTextAutocorrectApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextAutocorrectApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the autocorrect task for a given models
         * @throws {RequiredError}
         */
        applyTextTextAutocorrectPost(sentence?: string, model?: 'flexudy-t5-base-multi-sentence-doctor', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextAutocorrectApiFetchParamCreator(configuration).applyTextTextAutocorrectPost(sentence, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for autocorrect
         * @throws {RequiredError}
         */
        getVersionsTextTextAutocorrectGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextAutocorrectApiFetchParamCreator(configuration).getVersionsTextTextAutocorrectGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextBooleanQuestionGenerationApi - fetch parameter creator
 * @export
 */
export const TextTextBooleanQuestionGenerationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the boolean-question-generation task for a given models
         * @throws {RequiredError}
         */
        applyTextTextBooleanQuestionGenerationPost(text?: string, model?: 'questgen', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/boolean-question-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (text !== undefined) {
                localVarQueryParameter['text'] = ((text:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for boolean-question-generation
         * @throws {RequiredError}
         */
        getVersionsTextTextBooleanQuestionGenerationGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/boolean-question-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextBooleanQuestionGenerationApiType = { 
    applyTextTextBooleanQuestionGenerationPost(text?: string, model?: 'questgen', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextBooleanQuestionGenerationGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextBooleanQuestionGenerationApi - factory function to inject configuration 
 * @export
 */
export const TextTextBooleanQuestionGenerationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextBooleanQuestionGenerationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the boolean-question-generation task for a given models
         * @throws {RequiredError}
         */
        applyTextTextBooleanQuestionGenerationPost(text?: string, model?: 'questgen', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextBooleanQuestionGenerationApiFetchParamCreator(configuration).applyTextTextBooleanQuestionGenerationPost(text, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for boolean-question-generation
         * @throws {RequiredError}
         */
        getVersionsTextTextBooleanQuestionGenerationGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextBooleanQuestionGenerationApiFetchParamCreator(configuration).getVersionsTextTextBooleanQuestionGenerationGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextDependencyTrackingApi - fetch parameter creator
 * @export
 */
export const TextTextDependencyTrackingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the dependency-tracking task for a given models
         * @throws {RequiredError}
         */
        applyTextTextDependencyTrackingPost(inputString?: string, model?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/dependency-tracking/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (inputString !== undefined) {
                localVarQueryParameter['input_string'] = ((inputString:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for dependency-tracking
         * @throws {RequiredError}
         */
        getVersionsTextTextDependencyTrackingGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/dependency-tracking/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextDependencyTrackingApiType = { 
    applyTextTextDependencyTrackingPost(inputString?: string, model?: string, options?: RequestOptions): Promise<Object>,

    getVersionsTextTextDependencyTrackingGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextDependencyTrackingApi - factory function to inject configuration 
 * @export
 */
export const TextTextDependencyTrackingApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextDependencyTrackingApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the dependency-tracking task for a given models
         * @throws {RequiredError}
         */
        applyTextTextDependencyTrackingPost(inputString?: string, model?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextDependencyTrackingApiFetchParamCreator(configuration).applyTextTextDependencyTrackingPost(inputString, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for dependency-tracking
         * @throws {RequiredError}
         */
        getVersionsTextTextDependencyTrackingGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextDependencyTrackingApiFetchParamCreator(configuration).getVersionsTextTextDependencyTrackingGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextEmotionRecognitionApi - fetch parameter creator
 * @export
 */
export const TextTextEmotionRecognitionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the emotion-recognition task for a given models
         * @throws {RequiredError}
         */
        applyTextTextEmotionRecognitionPost(text?: string, model?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/emotion-recognition/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (text !== undefined) {
                localVarQueryParameter['text'] = ((text:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for emotion-recognition
         * @throws {RequiredError}
         */
        getVersionsTextTextEmotionRecognitionGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/emotion-recognition/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextEmotionRecognitionApiType = { 
    applyTextTextEmotionRecognitionPost(text?: string, model?: string, options?: RequestOptions): Promise<Object>,

    getVersionsTextTextEmotionRecognitionGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextEmotionRecognitionApi - factory function to inject configuration 
 * @export
 */
export const TextTextEmotionRecognitionApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextEmotionRecognitionApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the emotion-recognition task for a given models
         * @throws {RequiredError}
         */
        applyTextTextEmotionRecognitionPost(text?: string, model?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextEmotionRecognitionApiFetchParamCreator(configuration).applyTextTextEmotionRecognitionPost(text, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for emotion-recognition
         * @throws {RequiredError}
         */
        getVersionsTextTextEmotionRecognitionGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextEmotionRecognitionApiFetchParamCreator(configuration).getVersionsTextTextEmotionRecognitionGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextEntityExtractionApi - fetch parameter creator
 * @export
 */
export const TextTextEntityExtractionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the entity-extraction task for a given models
         * @throws {RequiredError}
         */
        applyTextTextEntityExtractionPost(inputString?: string, model?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/entity-extraction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (inputString !== undefined) {
                localVarQueryParameter['input_string'] = ((inputString:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for entity-extraction
         * @throws {RequiredError}
         */
        getVersionsTextTextEntityExtractionGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/entity-extraction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextEntityExtractionApiType = { 
    applyTextTextEntityExtractionPost(inputString?: string, model?: string, options?: RequestOptions): Promise<Object>,

    getVersionsTextTextEntityExtractionGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextEntityExtractionApi - factory function to inject configuration 
 * @export
 */
export const TextTextEntityExtractionApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextEntityExtractionApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the entity-extraction task for a given models
         * @throws {RequiredError}
         */
        applyTextTextEntityExtractionPost(inputString?: string, model?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextEntityExtractionApiFetchParamCreator(configuration).applyTextTextEntityExtractionPost(inputString, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for entity-extraction
         * @throws {RequiredError}
         */
        getVersionsTextTextEntityExtractionGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextEntityExtractionApiFetchParamCreator(configuration).getVersionsTextTextEntityExtractionGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextHateSpeechDetectionApi - fetch parameter creator
 * @export
 */
export const TextTextHateSpeechDetectionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the hate-speech-detection task for a given models
         * @throws {RequiredError}
         */
        applyTextTextHateSpeechDetectionPost(text?: string, model?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/hate-speech-detection/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (text !== undefined) {
                localVarQueryParameter['text'] = ((text:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for hate-speech-detection
         * @throws {RequiredError}
         */
        getVersionsTextTextHateSpeechDetectionGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/hate-speech-detection/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextHateSpeechDetectionApiType = { 
    applyTextTextHateSpeechDetectionPost(text?: string, model?: string, options?: RequestOptions): Promise<Object>,

    getVersionsTextTextHateSpeechDetectionGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextHateSpeechDetectionApi - factory function to inject configuration 
 * @export
 */
export const TextTextHateSpeechDetectionApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextHateSpeechDetectionApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the hate-speech-detection task for a given models
         * @throws {RequiredError}
         */
        applyTextTextHateSpeechDetectionPost(text?: string, model?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextHateSpeechDetectionApiFetchParamCreator(configuration).applyTextTextHateSpeechDetectionPost(text, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for hate-speech-detection
         * @throws {RequiredError}
         */
        getVersionsTextTextHateSpeechDetectionGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextHateSpeechDetectionApiFetchParamCreator(configuration).getVersionsTextTextHateSpeechDetectionGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextKeywordExtractionApi - fetch parameter creator
 * @export
 */
export const TextTextKeywordExtractionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the keyword-extraction task for a given models
         * @throws {RequiredError}
         */
        applyTextTextKeywordExtractionPost(text?: string, model?: 'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/keyword-extraction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (text !== undefined) {
                localVarQueryParameter['text'] = ((text:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for keyword-extraction
         * @throws {RequiredError}
         */
        getVersionsTextTextKeywordExtractionGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/keyword-extraction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextKeywordExtractionApiType = { 
    applyTextTextKeywordExtractionPost(text?: string, model?: 'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextKeywordExtractionGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextKeywordExtractionApi - factory function to inject configuration 
 * @export
 */
export const TextTextKeywordExtractionApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextKeywordExtractionApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the keyword-extraction task for a given models
         * @throws {RequiredError}
         */
        applyTextTextKeywordExtractionPost(text?: string, model?: 'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextKeywordExtractionApiFetchParamCreator(configuration).applyTextTextKeywordExtractionPost(text, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for keyword-extraction
         * @throws {RequiredError}
         */
        getVersionsTextTextKeywordExtractionGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextKeywordExtractionApiFetchParamCreator(configuration).getVersionsTextTextKeywordExtractionGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextLanguageDetectionApi - fetch parameter creator
 * @export
 */
export const TextTextLanguageDetectionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the language-detection task for a given models
         * @throws {RequiredError}
         */
        applyTextTextLanguageDetectionPost(text?: string, model?: 'toftrup-etal-2021', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/language-detection/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (text !== undefined) {
                localVarQueryParameter['text'] = ((text:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for language-detection
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageDetectionGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/language-detection/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextLanguageDetectionApiType = { 
    applyTextTextLanguageDetectionPost(text?: string, model?: 'toftrup-etal-2021', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextLanguageDetectionGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextLanguageDetectionApi - factory function to inject configuration 
 * @export
 */
export const TextTextLanguageDetectionApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextLanguageDetectionApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the language-detection task for a given models
         * @throws {RequiredError}
         */
        applyTextTextLanguageDetectionPost(text?: string, model?: 'toftrup-etal-2021', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextLanguageDetectionApiFetchParamCreator(configuration).applyTextTextLanguageDetectionPost(text, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for language-detection
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageDetectionGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextLanguageDetectionApiFetchParamCreator(configuration).getVersionsTextTextLanguageDetectionGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextLanguageGenerationApi - fetch parameter creator
 * @export
 */
export const TextTextLanguageGenerationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the language-generation task for a given models
         * @throws {RequiredError}
         */
        applyTextTextLanguageGenerationPost(text?: string, model?: 'EleutherAI-gpt-neo-2_7B', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/language-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (text !== undefined) {
                localVarQueryParameter['text'] = ((text:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for language-generation
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageGenerationGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/language-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextLanguageGenerationApiType = { 
    applyTextTextLanguageGenerationPost(text?: string, model?: 'EleutherAI-gpt-neo-2_7B', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextLanguageGenerationGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextLanguageGenerationApi - factory function to inject configuration 
 * @export
 */
export const TextTextLanguageGenerationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextLanguageGenerationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the language-generation task for a given models
         * @throws {RequiredError}
         */
        applyTextTextLanguageGenerationPost(text?: string, model?: 'EleutherAI-gpt-neo-2_7B', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextLanguageGenerationApiFetchParamCreator(configuration).applyTextTextLanguageGenerationPost(text, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for language-generation
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageGenerationGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextLanguageGenerationApiFetchParamCreator(configuration).getVersionsTextTextLanguageGenerationGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextLemmatizationApi - fetch parameter creator
 * @export
 */
export const TextTextLemmatizationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the lemmatization task for a given models
         * @throws {RequiredError}
         */
        applyTextTextLemmatizationPost(sentence?: string, model?: 'wordnet', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/lemmatization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (sentence !== undefined) {
                localVarQueryParameter['sentence'] = ((sentence:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for lemmatization
         * @throws {RequiredError}
         */
        getVersionsTextTextLemmatizationGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/lemmatization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextLemmatizationApiType = { 
    applyTextTextLemmatizationPost(sentence?: string, model?: 'wordnet', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextLemmatizationGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextLemmatizationApi - factory function to inject configuration 
 * @export
 */
export const TextTextLemmatizationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextLemmatizationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the lemmatization task for a given models
         * @throws {RequiredError}
         */
        applyTextTextLemmatizationPost(sentence?: string, model?: 'wordnet', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextLemmatizationApiFetchParamCreator(configuration).applyTextTextLemmatizationPost(sentence, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for lemmatization
         * @throws {RequiredError}
         */
        getVersionsTextTextLemmatizationGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextLemmatizationApiFetchParamCreator(configuration).getVersionsTextTextLemmatizationGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextNamedEntityRecognitionApi - fetch parameter creator
 * @export
 */
export const TextTextNamedEntityRecognitionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the named-entity-recognition task for a given models
         * @throws {RequiredError}
         */
        applyTextTextNamedEntityRecognitionPost(text?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/named-entity-recognition/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (text !== undefined) {
                localVarQueryParameter['text'] = ((text:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for named-entity-recognition
         * @throws {RequiredError}
         */
        getVersionsTextTextNamedEntityRecognitionGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/named-entity-recognition/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextNamedEntityRecognitionApiType = { 
    applyTextTextNamedEntityRecognitionPost(text?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextNamedEntityRecognitionGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextNamedEntityRecognitionApi - factory function to inject configuration 
 * @export
 */
export const TextTextNamedEntityRecognitionApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextNamedEntityRecognitionApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the named-entity-recognition task for a given models
         * @throws {RequiredError}
         */
        applyTextTextNamedEntityRecognitionPost(text?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextNamedEntityRecognitionApiFetchParamCreator(configuration).applyTextTextNamedEntityRecognitionPost(text, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for named-entity-recognition
         * @throws {RequiredError}
         */
        getVersionsTextTextNamedEntityRecognitionGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextNamedEntityRecognitionApiFetchParamCreator(configuration).getVersionsTextTextNamedEntityRecognitionGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextNextSentencePredictionApi - fetch parameter creator
 * @export
 */
export const TextTextNextSentencePredictionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the next-sentence-prediction task for a given models
         * @throws {RequiredError}
         */
        applyTextTextNextSentencePredictionPost(sentence1?: string, sentence2?: string, model?: 'bert-base-uncased', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/next-sentence-prediction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (sentence1 !== undefined) {
                localVarQueryParameter['sentence_1'] = ((sentence1:any):string);
            }

            if (sentence2 !== undefined) {
                localVarQueryParameter['sentence_2'] = ((sentence2:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for next-sentence-prediction
         * @throws {RequiredError}
         */
        getVersionsTextTextNextSentencePredictionGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/next-sentence-prediction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextNextSentencePredictionApiType = { 
    applyTextTextNextSentencePredictionPost(sentence1?: string, sentence2?: string, model?: 'bert-base-uncased', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextNextSentencePredictionGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextNextSentencePredictionApi - factory function to inject configuration 
 * @export
 */
export const TextTextNextSentencePredictionApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextNextSentencePredictionApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the next-sentence-prediction task for a given models
         * @throws {RequiredError}
         */
        applyTextTextNextSentencePredictionPost(sentence1?: string, sentence2?: string, model?: 'bert-base-uncased', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextNextSentencePredictionApiFetchParamCreator(configuration).applyTextTextNextSentencePredictionPost(sentence1, sentence2, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for next-sentence-prediction
         * @throws {RequiredError}
         */
        getVersionsTextTextNextSentencePredictionGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextNextSentencePredictionApiFetchParamCreator(configuration).getVersionsTextTextNextSentencePredictionGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextNextWordPredictionApi - fetch parameter creator
 * @export
 */
export const TextTextNextWordPredictionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the next-word-prediction task for a given models
         * @throws {RequiredError}
         */
        applyTextTextNextWordPredictionPost(sentence?: string, model?: 'bert-base-uncased' | 'roberta-base' | 'distilbert-base-uncased' | 'albert-base-v2', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/next-word-prediction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (sentence !== undefined) {
                localVarQueryParameter['sentence'] = ((sentence:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for next-word-prediction
         * @throws {RequiredError}
         */
        getVersionsTextTextNextWordPredictionGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/next-word-prediction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextNextWordPredictionApiType = { 
    applyTextTextNextWordPredictionPost(sentence?: string, model?: 'bert-base-uncased' | 'roberta-base' | 'distilbert-base-uncased' | 'albert-base-v2', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextNextWordPredictionGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextNextWordPredictionApi - factory function to inject configuration 
 * @export
 */
export const TextTextNextWordPredictionApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextNextWordPredictionApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the next-word-prediction task for a given models
         * @throws {RequiredError}
         */
        applyTextTextNextWordPredictionPost(sentence?: string, model?: 'bert-base-uncased' | 'roberta-base' | 'distilbert-base-uncased' | 'albert-base-v2', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextNextWordPredictionApiFetchParamCreator(configuration).applyTextTextNextWordPredictionPost(sentence, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for next-word-prediction
         * @throws {RequiredError}
         */
        getVersionsTextTextNextWordPredictionGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextNextWordPredictionApiFetchParamCreator(configuration).getVersionsTextTextNextWordPredictionGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextPluralApi - fetch parameter creator
 * @export
 */
export const TextTextPluralApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the plural task for a given models
         * @throws {RequiredError}
         */
        applyTextTextPluralPost(word?: string, count?: number, model?: 'inflect', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/plural/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (word !== undefined) {
                localVarQueryParameter['word'] = ((word:any):string);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = ((count:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for plural
         * @throws {RequiredError}
         */
        getVersionsTextTextPluralGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/plural/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextPluralApiType = { 
    applyTextTextPluralPost(word?: string, count?: number, model?: 'inflect', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextPluralGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextPluralApi - factory function to inject configuration 
 * @export
 */
export const TextTextPluralApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextPluralApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the plural task for a given models
         * @throws {RequiredError}
         */
        applyTextTextPluralPost(word?: string, count?: number, model?: 'inflect', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextPluralApiFetchParamCreator(configuration).applyTextTextPluralPost(word, count, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for plural
         * @throws {RequiredError}
         */
        getVersionsTextTextPluralGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextPluralApiFetchParamCreator(configuration).getVersionsTextTextPluralGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextProgrammingLanguageGenerationApi - fetch parameter creator
 * @export
 */
export const TextTextProgrammingLanguageGenerationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the programming-language-generation task for a given models
         * @throws {RequiredError}
         */
        applyTextTextProgrammingLanguageGenerationPost(codeSnippet?: string, model?: 'sentdex-GPyT', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/programming-language-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (codeSnippet !== undefined) {
                localVarQueryParameter['code_snippet'] = ((codeSnippet:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for programming-language-generation
         * @throws {RequiredError}
         */
        getVersionsTextTextProgrammingLanguageGenerationGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/programming-language-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextProgrammingLanguageGenerationApiType = { 
    applyTextTextProgrammingLanguageGenerationPost(codeSnippet?: string, model?: 'sentdex-GPyT', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextProgrammingLanguageGenerationGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextProgrammingLanguageGenerationApi - factory function to inject configuration 
 * @export
 */
export const TextTextProgrammingLanguageGenerationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextProgrammingLanguageGenerationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the programming-language-generation task for a given models
         * @throws {RequiredError}
         */
        applyTextTextProgrammingLanguageGenerationPost(codeSnippet?: string, model?: 'sentdex-GPyT', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextProgrammingLanguageGenerationApiFetchParamCreator(configuration).applyTextTextProgrammingLanguageGenerationPost(codeSnippet, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for programming-language-generation
         * @throws {RequiredError}
         */
        getVersionsTextTextProgrammingLanguageGenerationGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextProgrammingLanguageGenerationApiFetchParamCreator(configuration).getVersionsTextTextProgrammingLanguageGenerationGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextProgrammingLanguageIdentificationApi - fetch parameter creator
 * @export
 */
export const TextTextProgrammingLanguageIdentificationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the programming-language-identification task for a given models
         * @throws {RequiredError}
         */
        applyTextTextProgrammingLanguageIdentificationPost(text?: string, model?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/programming-language-identification/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (text !== undefined) {
                localVarQueryParameter['text'] = ((text:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for programming-language-identification
         * @throws {RequiredError}
         */
        getVersionsTextTextProgrammingLanguageIdentificationGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/programming-language-identification/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextProgrammingLanguageIdentificationApiType = { 
    applyTextTextProgrammingLanguageIdentificationPost(text?: string, model?: string, options?: RequestOptions): Promise<Object>,

    getVersionsTextTextProgrammingLanguageIdentificationGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextProgrammingLanguageIdentificationApi - factory function to inject configuration 
 * @export
 */
export const TextTextProgrammingLanguageIdentificationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextProgrammingLanguageIdentificationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the programming-language-identification task for a given models
         * @throws {RequiredError}
         */
        applyTextTextProgrammingLanguageIdentificationPost(text?: string, model?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextProgrammingLanguageIdentificationApiFetchParamCreator(configuration).applyTextTextProgrammingLanguageIdentificationPost(text, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for programming-language-identification
         * @throws {RequiredError}
         */
        getVersionsTextTextProgrammingLanguageIdentificationGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextProgrammingLanguageIdentificationApiFetchParamCreator(configuration).getVersionsTextTextProgrammingLanguageIdentificationGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextQuestionAnsweringApi - fetch parameter creator
 * @export
 */
export const TextTextQuestionAnsweringApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the question-answering task for a given models
         * @throws {RequiredError}
         */
        applyTextTextQuestionAnsweringPost(context?: string, question?: string, model?: 'deepset_bert-base-cased-squad2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'distilbert-base-cased-distilled-squad', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/question-answering/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (context !== undefined) {
                localVarQueryParameter['context'] = ((context:any):string);
            }

            if (question !== undefined) {
                localVarQueryParameter['question'] = ((question:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for question-answering
         * @throws {RequiredError}
         */
        getVersionsTextTextQuestionAnsweringGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/question-answering/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextQuestionAnsweringApiType = { 
    applyTextTextQuestionAnsweringPost(context?: string, question?: string, model?: 'deepset_bert-base-cased-squad2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'distilbert-base-cased-distilled-squad', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextQuestionAnsweringGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextQuestionAnsweringApi - factory function to inject configuration 
 * @export
 */
export const TextTextQuestionAnsweringApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextQuestionAnsweringApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the question-answering task for a given models
         * @throws {RequiredError}
         */
        applyTextTextQuestionAnsweringPost(context?: string, question?: string, model?: 'deepset_bert-base-cased-squad2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'distilbert-base-cased-distilled-squad', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextQuestionAnsweringApiFetchParamCreator(configuration).applyTextTextQuestionAnsweringPost(context, question, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for question-answering
         * @throws {RequiredError}
         */
        getVersionsTextTextQuestionAnsweringGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextQuestionAnsweringApiFetchParamCreator(configuration).getVersionsTextTextQuestionAnsweringGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextSentencePairModelingApi - fetch parameter creator
 * @export
 */
export const TextTextSentencePairModelingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the sentence-pair-modeling task for a given models
         * @throws {RequiredError}
         */
        applyTextTextSentencePairModelingPost(sentence?: string, model?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/sentence-pair-modeling/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (sentence !== undefined) {
                localVarQueryParameter['sentence'] = ((sentence:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for sentence-pair-modeling
         * @throws {RequiredError}
         */
        getVersionsTextTextSentencePairModelingGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/sentence-pair-modeling/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextSentencePairModelingApiType = { 
    applyTextTextSentencePairModelingPost(sentence?: string, model?: string, options?: RequestOptions): Promise<Object>,

    getVersionsTextTextSentencePairModelingGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextSentencePairModelingApi - factory function to inject configuration 
 * @export
 */
export const TextTextSentencePairModelingApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextSentencePairModelingApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the sentence-pair-modeling task for a given models
         * @throws {RequiredError}
         */
        applyTextTextSentencePairModelingPost(sentence?: string, model?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextSentencePairModelingApiFetchParamCreator(configuration).applyTextTextSentencePairModelingPost(sentence, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for sentence-pair-modeling
         * @throws {RequiredError}
         */
        getVersionsTextTextSentencePairModelingGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextSentencePairModelingApiFetchParamCreator(configuration).getVersionsTextTextSentencePairModelingGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextSentenceParaphraserApi - fetch parameter creator
 * @export
 */
export const TextTextSentenceParaphraserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the sentence-paraphraser task for a given models
         * @throws {RequiredError}
         */
        applyTextTextSentenceParaphraserPost(context?: string, model?: 'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/sentence-paraphraser/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (context !== undefined) {
                localVarQueryParameter['context'] = ((context:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for sentence-paraphraser
         * @throws {RequiredError}
         */
        getVersionsTextTextSentenceParaphraserGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/sentence-paraphraser/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextSentenceParaphraserApiType = { 
    applyTextTextSentenceParaphraserPost(context?: string, model?: 'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextSentenceParaphraserGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextSentenceParaphraserApi - factory function to inject configuration 
 * @export
 */
export const TextTextSentenceParaphraserApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextSentenceParaphraserApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the sentence-paraphraser task for a given models
         * @throws {RequiredError}
         */
        applyTextTextSentenceParaphraserPost(context?: string, model?: 'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextSentenceParaphraserApiFetchParamCreator(configuration).applyTextTextSentenceParaphraserPost(context, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for sentence-paraphraser
         * @throws {RequiredError}
         */
        getVersionsTextTextSentenceParaphraserGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextSentenceParaphraserApiFetchParamCreator(configuration).getVersionsTextTextSentenceParaphraserGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextSentimentAnalysisApi - fetch parameter creator
 * @export
 */
export const TextTextSentimentAnalysisApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the sentiment-analysis task for a given models
         * @throws {RequiredError}
         */
        applyTextTextSentimentAnalysisPost(text?: string, model?: 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased' | 'distilbert-base-uncased-finetuned-sst-2-english' | 'zero-shot-classification-facebook-bart-large-mnli', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/sentiment-analysis/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (text !== undefined) {
                localVarQueryParameter['text'] = ((text:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for sentiment-analysis
         * @throws {RequiredError}
         */
        getVersionsTextTextSentimentAnalysisGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/sentiment-analysis/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextSentimentAnalysisApiType = { 
    applyTextTextSentimentAnalysisPost(text?: string, model?: 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased' | 'distilbert-base-uncased-finetuned-sst-2-english' | 'zero-shot-classification-facebook-bart-large-mnli', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextSentimentAnalysisGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextSentimentAnalysisApi - factory function to inject configuration 
 * @export
 */
export const TextTextSentimentAnalysisApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextSentimentAnalysisApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the sentiment-analysis task for a given models
         * @throws {RequiredError}
         */
        applyTextTextSentimentAnalysisPost(text?: string, model?: 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased' | 'distilbert-base-uncased-finetuned-sst-2-english' | 'zero-shot-classification-facebook-bart-large-mnli', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextSentimentAnalysisApiFetchParamCreator(configuration).applyTextTextSentimentAnalysisPost(text, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for sentiment-analysis
         * @throws {RequiredError}
         */
        getVersionsTextTextSentimentAnalysisGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextSentimentAnalysisApiFetchParamCreator(configuration).getVersionsTextTextSentimentAnalysisGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextSimilarityApi - fetch parameter creator
 * @export
 */
export const TextTextSimilarityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the similarity task for a given models
         * @throws {RequiredError}
         */
        applyTextTextSimilarityPost(sentence1?: string, sentence2?: string, model?: 'all-MiniLM-L6-v2', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/similarity/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (sentence1 !== undefined) {
                localVarQueryParameter['sentence_1'] = ((sentence1:any):string);
            }

            if (sentence2 !== undefined) {
                localVarQueryParameter['sentence_2'] = ((sentence2:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for similarity
         * @throws {RequiredError}
         */
        getVersionsTextTextSimilarityGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/similarity/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextSimilarityApiType = { 
    applyTextTextSimilarityPost(sentence1?: string, sentence2?: string, model?: 'all-MiniLM-L6-v2', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextSimilarityGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextSimilarityApi - factory function to inject configuration 
 * @export
 */
export const TextTextSimilarityApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextSimilarityApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the similarity task for a given models
         * @throws {RequiredError}
         */
        applyTextTextSimilarityPost(sentence1?: string, sentence2?: string, model?: 'all-MiniLM-L6-v2', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextSimilarityApiFetchParamCreator(configuration).applyTextTextSimilarityPost(sentence1, sentence2, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for similarity
         * @throws {RequiredError}
         */
        getVersionsTextTextSimilarityGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextSimilarityApiFetchParamCreator(configuration).getVersionsTextTextSimilarityGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextSummarizationApi - fetch parameter creator
 * @export
 */
export const TextTextSummarizationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the summarization task for a given models
         * @throws {RequiredError}
         */
        applyTextTextSummarizationPost(text?: string, sourceLanguage?: string, maxLength?: number, minLength?: number, model?: 'distilbart-cnn-12-6', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/summarization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (text !== undefined) {
                localVarQueryParameter['text'] = ((text:any):string);
            }

            if (sourceLanguage !== undefined) {
                localVarQueryParameter['source_language'] = ((sourceLanguage:any):string);
            }

            if (maxLength !== undefined) {
                localVarQueryParameter['max_length'] = ((maxLength:any):string);
            }

            if (minLength !== undefined) {
                localVarQueryParameter['min_length'] = ((minLength:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for summarization
         * @throws {RequiredError}
         */
        getVersionsTextTextSummarizationGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/summarization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextSummarizationApiType = { 
    applyTextTextSummarizationPost(text?: string, sourceLanguage?: string, maxLength?: number, minLength?: number, model?: 'distilbart-cnn-12-6', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextSummarizationGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextSummarizationApi - factory function to inject configuration 
 * @export
 */
export const TextTextSummarizationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextSummarizationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the summarization task for a given models
         * @throws {RequiredError}
         */
        applyTextTextSummarizationPost(text?: string, sourceLanguage?: string, maxLength?: number, minLength?: number, model?: 'distilbart-cnn-12-6', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextSummarizationApiFetchParamCreator(configuration).applyTextTextSummarizationPost(text, sourceLanguage, maxLength, minLength, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for summarization
         * @throws {RequiredError}
         */
        getVersionsTextTextSummarizationGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextSummarizationApiFetchParamCreator(configuration).getVersionsTextTextSummarizationGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextTranslationApi - fetch parameter creator
 * @export
 */
export const TextTextTranslationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the translation task for a given models
         * @throws {RequiredError}
         */
        applyTextTextTranslationPost(inputString?: string, sourceLanguage?: string, targetLanguage?: string, model?: 'Helsinki-NLP', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/translation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (inputString !== undefined) {
                localVarQueryParameter['input_string'] = ((inputString:any):string);
            }

            if (sourceLanguage !== undefined) {
                localVarQueryParameter['source_language'] = ((sourceLanguage:any):string);
            }

            if (targetLanguage !== undefined) {
                localVarQueryParameter['target_language'] = ((targetLanguage:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for translation
         * @throws {RequiredError}
         */
        getVersionsTextTextTranslationGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/translation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextTranslationApiType = { 
    applyTextTextTranslationPost(inputString?: string, sourceLanguage?: string, targetLanguage?: string, model?: 'Helsinki-NLP', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextTranslationGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextTranslationApi - factory function to inject configuration 
 * @export
 */
export const TextTextTranslationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextTranslationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the translation task for a given models
         * @throws {RequiredError}
         */
        applyTextTextTranslationPost(inputString?: string, sourceLanguage?: string, targetLanguage?: string, model?: 'Helsinki-NLP', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextTranslationApiFetchParamCreator(configuration).applyTextTextTranslationPost(inputString, sourceLanguage, targetLanguage, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for translation
         * @throws {RequiredError}
         */
        getVersionsTextTextTranslationGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextTranslationApiFetchParamCreator(configuration).getVersionsTextTextTranslationGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextTransliterationApi - fetch parameter creator
 * @export
 */
export const TextTextTransliterationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the transliteration task for a given models
         * @throws {RequiredError}
         */
        applyTextTextTransliterationPost(text?: string, language?: string, model?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/transliteration/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (text !== undefined) {
                localVarQueryParameter['text'] = ((text:any):string);
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = ((language:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for transliteration
         * @throws {RequiredError}
         */
        getVersionsTextTextTransliterationGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/transliteration/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextTransliterationApiType = { 
    applyTextTextTransliterationPost(text?: string, language?: string, model?: string, options?: RequestOptions): Promise<Object>,

    getVersionsTextTextTransliterationGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextTransliterationApi - factory function to inject configuration 
 * @export
 */
export const TextTextTransliterationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextTransliterationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the transliteration task for a given models
         * @throws {RequiredError}
         */
        applyTextTextTransliterationPost(text?: string, language?: string, model?: string, options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextTransliterationApiFetchParamCreator(configuration).applyTextTextTransliterationPost(text, language, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for transliteration
         * @throws {RequiredError}
         */
        getVersionsTextTextTransliterationGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextTransliterationApiFetchParamCreator(configuration).getVersionsTextTextTransliterationGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TextTextWordAlignmentApi - fetch parameter creator
 * @export
 */
export const TextTextWordAlignmentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the word-alignment task for a given models
         * @throws {RequiredError}
         */
        applyTextTextWordAlignmentPost(inputStringLanguage1?: string, inputStringLanguage2?: string, model?: 'bert-base-multilingual-cased', options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/word-alignment/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (inputStringLanguage1 !== undefined) {
                localVarQueryParameter['input_string_language_1'] = ((inputStringLanguage1:any):string);
            }

            if (inputStringLanguage2 !== undefined) {
                localVarQueryParameter['input_string_language_2'] = ((inputStringLanguage2:any):string);
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = ((model:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for word-alignment
         * @throws {RequiredError}
         */
        getVersionsTextTextWordAlignmentGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/text/text/word-alignment/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TextTextWordAlignmentApiType = { 
    applyTextTextWordAlignmentPost(inputStringLanguage1?: string, inputStringLanguage2?: string, model?: 'bert-base-multilingual-cased', options?: RequestOptions): Promise<Object>,

    getVersionsTextTextWordAlignmentGet(options?: RequestOptions): Promise<Object>,
}

/**
 * TextTextWordAlignmentApi - factory function to inject configuration 
 * @export
 */
export const TextTextWordAlignmentApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TextTextWordAlignmentApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Apply model for the word-alignment task for a given models
         * @throws {RequiredError}
         */
        applyTextTextWordAlignmentPost(inputStringLanguage1?: string, inputStringLanguage2?: string, model?: 'bert-base-multilingual-cased', options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextWordAlignmentApiFetchParamCreator(configuration).applyTextTextWordAlignmentPost(inputStringLanguage1, inputStringLanguage2, model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get list of models available for word-alignment
         * @throws {RequiredError}
         */
        getVersionsTextTextWordAlignmentGet(options?: RequestOptions = {}): Promise<Object> {
            const localVarFetchArgs = TextTextWordAlignmentApiFetchParamCreator(configuration).getVersionsTextTextWordAlignmentGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

export type ApiTypes = { 
    ImageImageBackgroundRemovalApi: ImageImageBackgroundRemovalApiType,

    ImageImageColorizationApi: ImageImageColorizationApiType,

    ImageImageFaceBluringApi: ImageImageFaceBluringApiType,

    ImageImageRestorationApi: ImageImageRestorationApiType,

    ImageImageSuperResolutionApi: ImageImageSuperResolutionApiType,

    ImageImageUncolorizationApi: ImageImageUncolorizationApiType,

    TextTextAutocorrectApi: TextTextAutocorrectApiType,

    TextTextBooleanQuestionGenerationApi: TextTextBooleanQuestionGenerationApiType,

    TextTextDependencyTrackingApi: TextTextDependencyTrackingApiType,

    TextTextEmotionRecognitionApi: TextTextEmotionRecognitionApiType,

    TextTextEntityExtractionApi: TextTextEntityExtractionApiType,

    TextTextHateSpeechDetectionApi: TextTextHateSpeechDetectionApiType,

    TextTextKeywordExtractionApi: TextTextKeywordExtractionApiType,

    TextTextLanguageDetectionApi: TextTextLanguageDetectionApiType,

    TextTextLanguageGenerationApi: TextTextLanguageGenerationApiType,

    TextTextLemmatizationApi: TextTextLemmatizationApiType,

    TextTextNamedEntityRecognitionApi: TextTextNamedEntityRecognitionApiType,

    TextTextNextSentencePredictionApi: TextTextNextSentencePredictionApiType,

    TextTextNextWordPredictionApi: TextTextNextWordPredictionApiType,

    TextTextPluralApi: TextTextPluralApiType,

    TextTextProgrammingLanguageGenerationApi: TextTextProgrammingLanguageGenerationApiType,

    TextTextProgrammingLanguageIdentificationApi: TextTextProgrammingLanguageIdentificationApiType,

    TextTextQuestionAnsweringApi: TextTextQuestionAnsweringApiType,

    TextTextSentencePairModelingApi: TextTextSentencePairModelingApiType,

    TextTextSentenceParaphraserApi: TextTextSentenceParaphraserApiType,

    TextTextSentimentAnalysisApi: TextTextSentimentAnalysisApiType,

    TextTextSimilarityApi: TextTextSimilarityApiType,

    TextTextSummarizationApi: TextTextSummarizationApiType,

    TextTextTranslationApi: TextTextTranslationApiType,

    TextTextTransliterationApi: TextTextTransliterationApiType,

    TextTextWordAlignmentApi: TextTextWordAlignmentApiType,
 }
